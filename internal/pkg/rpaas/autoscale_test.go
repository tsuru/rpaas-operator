// Copyright 2023 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpaas

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"

	"github.com/tsuru/rpaas-operator/api/v1alpha1"
	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
	"github.com/tsuru/rpaas-operator/pkg/runtime"
)

func Test_k8sRpaasManager_GetAutoscale(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		instance    func(*v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance
		expected    *autogenerated.Autoscale
		expectedErr string
	}{
		"when autoscale is not set": {},

		"when autoscale is set": {
			instance: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas:                    autogenerated.PtrInt32(3),
					MaxReplicas:                    int32(25),
					TargetCPUUtilizationPercentage: autogenerated.PtrInt32(75),
				}
				return ri
			},
			expected: &autogenerated.Autoscale{
				MinReplicas: int32(3),
				MaxReplicas: int32(25),
				Cpu:         autogenerated.PtrInt32(75),
			},
		},

		"autoscale set with schedules": {
			instance: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas: autogenerated.PtrInt32(0),
					MaxReplicas: 50,
					Schedules: []v1alpha1.ScheduledWindow{
						{MinReplicas: 1, Start: "00 08 * * 1-5", End: "00 20 * * 1-5"},
						{MinReplicas: 6, Start: "00 20 * * 2", End: "00 01 * * 3"},
					},
				}
				return ri
			},
			expected: &autogenerated.Autoscale{
				MinReplicas: 0,
				MaxReplicas: 50,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 1, Start: "00 08 * * 1-5", End: "00 20 * * 1-5"},
					{MinReplicas: 6, Start: "00 20 * * 2", End: "00 01 * * 3"},
				},
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			instance := newEmptyRpaasInstance()
			if tt.instance != nil {
				instance = tt.instance(instance)
			}

			m := &k8sRpaasManager{
				cli: fake.NewClientBuilder().
					WithScheme(runtime.NewScheme()).
					WithRuntimeObjects(instance).
					Build(),
			}

			autoscale, err := m.GetAutoscale(context.Background(), instance.Name)
			if tt.expectedErr != "" {
				assert.EqualError(t, err, tt.expectedErr)
				return
			}

			require.NoError(t, err)
			assert.Equal(t, tt.expected, autoscale)
		})
	}
}

func Test_k8sRpaasManager_UpdateAutoscale(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		instance    func(*v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance
		autoscale   autogenerated.Autoscale
		expected    func(*v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance
		expectedErr string
	}{
		"max replicas == 0": {
			expectedErr: "max replicas must be greater than zero",
		},

		"max replicas < 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: -100,
			},
			expectedErr: "max replicas must be greater than zero",
		},

		"min replicas < 0": {
			autoscale: autogenerated.Autoscale{
				MinReplicas: -100,
				MaxReplicas: 42,
			},
			expectedErr: "min replicas must be greater or equal than zero",
		},

		"min replicas > max replicas": {
			autoscale: autogenerated.Autoscale{
				MinReplicas: 10,
				MaxReplicas: 1,
			},
			expectedErr: "min replicas must not be greater than max replicas",
		},

		"no targets set": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
			},
			expectedErr: "you must provide either CPU, memory, RPS targets, or schedules",
		},

		"cpu < 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Cpu:         autogenerated.PtrInt32(-100),
			},
			expectedErr: "CPU must be greater than zero",
		},

		"cpu = 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Cpu:         autogenerated.PtrInt32(0),
			},
			expectedErr: "CPU must be greater than zero",
		},

		"memory < 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Memory:      autogenerated.PtrInt32(-100),
			},
			expectedErr: "memory must be greater than zero",
		},

		"memory = 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Memory:      autogenerated.PtrInt32(0),
			},
			expectedErr: "memory must be greater than zero",
		},

		"RPS < 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Rps:         autogenerated.PtrInt32(-100),
			},
			expectedErr: "RPS must be greater than zero",
		},

		"RPS = 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Rps:         autogenerated.PtrInt32(0),
			},
			expectedErr: "RPS must be greater than zero",
		},

		"schedule with min replicas < 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: -100},
				},
			},
			expectedErr: "scheduled window min replicas must be greater than zero",
		},

		"schedule with min replicas = 0": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{},
				},
			},
			expectedErr: "scheduled window min replicas must be greater than zero",
		},

		"with schedule, min replicas > general max replicas": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 43},
				},
			},
			expectedErr: "scheduled window min replicas must be up to max replicas",
		},

		"with schedule, empty start cron expression": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 3},
				},
			},
			expectedErr: "start cron expression not provided",
		},

		"with schedule, invalid start cron expression": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 3, Start: "@hourly"},
				},
			},
			expectedErr: "could not validate the scheduled window start cron expression \"@hourly\": parser does not accept descriptors: @hourly",
		},

		"with schedule, empty end cron expression": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 3, Start: "00 08 * * 1-5"},
				},
			},
			expectedErr: "end cron expression not provided",
		},

		"with schedule, invalid end cron expression": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 3, Start: "00 08 * * 1-5", End: "@hourly"},
				},
			},
			expectedErr: "could not validate the scheduled window end cron expression \"@hourly\": parser does not accept descriptors: @hourly",
		},

		"with schedule, start = end cron expression": {
			autoscale: autogenerated.Autoscale{
				MaxReplicas: 42,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 3, Start: "00 08 * * 1-5", End: "00 08 * * 1-5"},
				},
			},
			expectedErr: "start and end cannot have exactly the same cron expression",
		},

		"when autoscale is not set before, should set it": {
			autoscale: autogenerated.Autoscale{
				MinReplicas: int32(2),
				MaxReplicas: int32(30),
				Cpu:         autogenerated.PtrInt32(75),
			},
			expected: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.ResourceVersion = "1000" // means it was updated
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas:                    autogenerated.PtrInt32(2),
					MaxReplicas:                    int32(30),
					TargetCPUUtilizationPercentage: autogenerated.PtrInt32(75),
				}
				return ri
			},
		},

		"when autoscale is already set, should update it": {
			instance: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas:                    autogenerated.PtrInt32(2),
					MaxReplicas:                    int32(30),
					TargetCPUUtilizationPercentage: autogenerated.PtrInt32(75),
				}
				return ri
			},
			autoscale: autogenerated.Autoscale{
				MinReplicas: int32(5),
				MaxReplicas: int32(30),
				Rps:         autogenerated.PtrInt32(500),
			},
			expected: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.ResourceVersion = "1000" // means it was updated
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas:             autogenerated.PtrInt32(5),
					MaxReplicas:             int32(30),
					TargetRequestsPerSecond: autogenerated.PtrInt32(500),
				}
				return ri
			},
		},

		"autoscale with schedules": {
			autoscale: autogenerated.Autoscale{
				MinReplicas: 0,
				MaxReplicas: 50,
				Schedules: []autogenerated.ScheduledWindow{
					{MinReplicas: 1, Start: "00 08 * * 1-5", End: "00 20 * * 1-5"},
					{MinReplicas: 6, Start: "00 20 * * 2", End: "00 01 * * 3"},
				},
			},
			expected: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.ResourceVersion = "1000" // means it was updated
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas: autogenerated.PtrInt32(0),
					MaxReplicas: 50,
					Schedules: []v1alpha1.ScheduledWindow{
						{MinReplicas: 1, Start: "00 08 * * 1-5", End: "00 20 * * 1-5"},
						{MinReplicas: 6, Start: "00 20 * * 2", End: "00 01 * * 3"},
					},
				}
				return ri
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			instance := newEmptyRpaasInstance()
			if tt.instance != nil {
				instance = tt.instance(instance)
			}

			m := &k8sRpaasManager{
				cli: fake.NewClientBuilder().
					WithScheme(runtime.NewScheme()).
					WithRuntimeObjects(instance).
					Build(),
			}

			err := m.UpdateAutoscale(context.Background(), instance.Name, tt.autoscale)
			if tt.expectedErr != "" {
				assert.EqualError(t, err, tt.expectedErr)
				return
			}
			assert.NoError(t, err)

			require.NotNil(t, tt.expected, "you must provide an expected function")

			var i v1alpha1.RpaasInstance
			err = m.cli.Get(context.Background(), types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace}, &i)
			require.NoError(t, err)
			assert.Equal(t, tt.expected(instance), i.DeepCopy())
		})
	}
}

func Test_k8sRpaasManager_DeleteAutoscale(t *testing.T) {
	t.Parallel()

	tests := map[string]struct {
		instance    func(*v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance
		autoscale   autogenerated.Autoscale
		expected    func(*v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance
		expectedErr string
	}{
		"when autoscale is not set, should do nothing": {
			expected: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.ResourceVersion = "1000" // means it was updated
				return ri
			},
		},

		"when autoscale is already set, should set it to nil": {
			instance: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
					MinReplicas:                    autogenerated.PtrInt32(0),
					MaxReplicas:                    10,
					TargetCPUUtilizationPercentage: autogenerated.PtrInt32(80),
				}
				return ri
			},
			expected: func(ri *v1alpha1.RpaasInstance) *v1alpha1.RpaasInstance {
				ri.ResourceVersion = "1000" // means it was updated
				ri.Spec.Autoscale = nil
				return ri
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			instance := newEmptyRpaasInstance()
			if tt.instance != nil {
				instance = tt.instance(instance)
			}

			m := &k8sRpaasManager{
				cli: fake.NewClientBuilder().
					WithScheme(runtime.NewScheme()).
					WithRuntimeObjects(instance).
					Build(),
			}

			err := m.DeleteAutoscale(context.Background(), instance.Name)
			assert.NoError(t, err)

			require.NotNil(t, tt.expected, "you must provide an expected function")

			var i v1alpha1.RpaasInstance
			err = m.cli.Get(context.Background(), types.NamespacedName{Name: instance.Name, Namespace: instance.Namespace}, &i)
			require.NoError(t, err)
			assert.Equal(t, tt.expected(instance), i.DeepCopy())
		})
	}
}
