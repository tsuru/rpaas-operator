// Copyright 2023 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpaas

import (
	"context"

	"github.com/tsuru/rpaas-operator/api/v1alpha1"
	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
)

var ErrAutoscaleNotFound = &ValidationError{Msg: "autoscale not found"}

func (m *k8sRpaasManager) GetAutoscale(ctx context.Context, instanceName string) (*autogenerated.Autoscale, error) {
	instance, err := m.GetInstance(ctx, instanceName)
	if err != nil {
		return nil, err
	}

	return m.getAutoscale(instance), nil
}

func (m *k8sRpaasManager) UpdateAutoscale(ctx context.Context, instanceName string, autoscale autogenerated.Autoscale) error {
	instance, err := m.GetInstance(ctx, instanceName)
	if err != nil {
		return err
	}

	return m.updateAutoscale(ctx, instance, autoscale)
}

func (m *k8sRpaasManager) DeleteAutoscale(ctx context.Context, instanceName string) error {
	instance, err := m.GetInstance(ctx, instanceName)
	if err != nil {
		return err
	}
	originalInstance := instance.DeepCopy()

	instance.Spec.Autoscale = nil

	return m.patchInstance(ctx, originalInstance, instance)
}

func (m *k8sRpaasManager) getAutoscale(instance *v1alpha1.RpaasInstance) *autogenerated.Autoscale {
	a := instance.Spec.Autoscale
	if a == nil {
		return nil
	}

	var minReplicas int32
	if m := a.MinReplicas; m != nil {
		minReplicas = *m
	}

	return &autogenerated.Autoscale{
		MinReplicas: minReplicas,
		MaxReplicas: a.MaxReplicas,
		Cpu:         a.TargetCPUUtilizationPercentage,
		Memory:      a.TargetMemoryUtilizationPercentage,
		Rps:         a.TargetRequestsPerSecond,
	}
}

func (m *k8sRpaasManager) updateAutoscale(ctx context.Context, instance *v1alpha1.RpaasInstance, autoscale autogenerated.Autoscale) error {
	if err := validateAutoscale(&autoscale); err != nil {
		return err
	}

	originalInstance := instance.DeepCopy()

	instance.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
		MinReplicas:                       &autoscale.MinReplicas,
		MaxReplicas:                       autoscale.MaxReplicas,
		TargetCPUUtilizationPercentage:    autoscale.Cpu,
		TargetMemoryUtilizationPercentage: autoscale.Memory,
		TargetRequestsPerSecond:           autoscale.Rps,
	}

	return m.patchInstance(ctx, originalInstance, instance)
}

func validateAutoscale(a *autogenerated.Autoscale) error {
	if a == nil {
		return &ValidationError{Msg: "autoscale not provided"}
	}

	if a.MaxReplicas < 0 {
		return &ValidationError{Msg: "max replicas must be greater or equal to zero"}
	}

	if a.MaxReplicas == 0 {
		return &ValidationError{Msg: "max replicas is required"}
	}

	if a.MinReplicas > a.MaxReplicas {
		return &ValidationError{Msg: "min replicas must not be greater than max replicas"}
	}

	if a.Cpu == nil && a.Memory == nil && a.Rps == nil {
		return &ValidationError{Msg: "you must provided either CPU, memory or RPS targets"}
	}

	if cpu := a.Cpu; cpu != nil && *cpu < 0 {
		return &ValidationError{Msg: "CPU must be greater than zero"}
	}

	if memory := a.Memory; memory != nil && *memory < 0 {
		return &ValidationError{Msg: "Memory must be greater than zero"}
	}

	if rps := a.Rps; rps != nil && *rps < 0 {
		return &ValidationError{Msg: "RPS must be greater than zero"}
	}

	return nil
}
