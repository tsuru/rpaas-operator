// Copyright 2023 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package rpaas

import (
	"context"
	"fmt"

	cron "github.com/robfig/cron/v3"

	"github.com/tsuru/rpaas-operator/api/v1alpha1"
	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
)

var CronParser = cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)

func (m *k8sRpaasManager) GetAutoscale(ctx context.Context, instanceName string) (*autogenerated.Autoscale, error) {
	instance, err := m.GetInstance(ctx, instanceName)
	if err != nil {
		return nil, err
	}

	return m.getAutoscale(instance), nil
}

func (m *k8sRpaasManager) UpdateAutoscale(ctx context.Context, instanceName string, autoscale autogenerated.Autoscale) error {
	instance, err := m.GetInstance(ctx, instanceName)
	if err != nil {
		return err
	}

	return m.updateAutoscale(ctx, instance, autoscale)
}

func (m *k8sRpaasManager) DeleteAutoscale(ctx context.Context, instanceName string) error {
	instance, err := m.GetInstance(ctx, instanceName)
	if err != nil {
		return err
	}
	originalInstance := instance.DeepCopy()

	instance.Spec.Autoscale = nil

	return m.patchInstance(ctx, originalInstance, instance)
}

func (m *k8sRpaasManager) getAutoscale(instance *v1alpha1.RpaasInstance) *autogenerated.Autoscale {
	a := instance.Spec.Autoscale
	if a == nil {
		return nil
	}

	var minReplicas int32
	if m := a.MinReplicas; m != nil {
		minReplicas = *m
	}

	var sws []autogenerated.ScheduledWindow
	for _, sw := range a.Schedules {
		sws = append(sws, autogenerated.ScheduledWindow{
			MinReplicas: sw.MinReplicas,
			Start:       sw.Start,
			End:         sw.End,
		})
	}

	var behavior *autogenerated.Behavior
	if b := a.Behavior; b != nil && b.ScaleDown != nil {
		behavior = &autogenerated.Behavior{
			ScaleDown: &autogenerated.ScaleDown{},
		}
		if b.ScaleDown.StabilizationWindowSeconds != nil {
			behavior.ScaleDown.StabilizationWindowSeconds = b.ScaleDown.StabilizationWindowSeconds
		}
		if b.ScaleDown.PercentPolicyValue != nil {
			behavior.ScaleDown.PercentPolicyValue = b.ScaleDown.PercentPolicyValue
		}
		if b.ScaleDown.UnitsPolicyValue != nil {
			behavior.ScaleDown.UnitsPolicyValue = b.ScaleDown.UnitsPolicyValue
		}
	}

	return &autogenerated.Autoscale{
		MinReplicas: minReplicas,
		MaxReplicas: a.MaxReplicas,
		Cpu:         a.TargetCPUUtilizationPercentage,
		Memory:      a.TargetMemoryUtilizationPercentage,
		Rps:         a.TargetRequestsPerSecond,
		Schedules:   sws,
		Behavior:    behavior,
	}
}

func (m *k8sRpaasManager) updateAutoscale(ctx context.Context, instance *v1alpha1.RpaasInstance, autoscale autogenerated.Autoscale) error {
	if err := validateAutoscale(&autoscale); err != nil {
		return err
	}

	originalInstance := instance.DeepCopy()

	var sws []v1alpha1.ScheduledWindow
	for _, sw := range autoscale.Schedules {
		sws = append(sws, v1alpha1.ScheduledWindow{
			MinReplicas: sw.MinReplicas,
			Start:       sw.Start,
			End:         sw.End,
		})
	}

	var behavior *v1alpha1.Behavior
	if b := autoscale.Behavior; b != nil && b.ScaleDown != nil {
		behavior = &v1alpha1.Behavior{}
		scaleDown := &v1alpha1.ScaleDown{}
		if b.ScaleDown.PercentPolicyValue != nil {
			scaleDown.PercentPolicyValue = b.ScaleDown.PercentPolicyValue
		}
		if b.ScaleDown.UnitsPolicyValue != nil {
			scaleDown.UnitsPolicyValue = b.ScaleDown.UnitsPolicyValue
		}
		if b.ScaleDown.StabilizationWindowSeconds != nil {
			scaleDown.StabilizationWindowSeconds = b.ScaleDown.StabilizationWindowSeconds
		}
		behavior.ScaleDown = scaleDown
	}

	instance.Spec.Autoscale = &v1alpha1.RpaasInstanceAutoscaleSpec{
		MinReplicas:                       &autoscale.MinReplicas,
		MaxReplicas:                       autoscale.MaxReplicas,
		TargetCPUUtilizationPercentage:    autoscale.Cpu,
		TargetMemoryUtilizationPercentage: autoscale.Memory,
		TargetRequestsPerSecond:           autoscale.Rps,
		Schedules:                         sws,
		Behavior:                          behavior,
	}

	return m.patchInstance(ctx, originalInstance, instance)
}

func validateAutoscale(a *autogenerated.Autoscale) error {
	if a == nil {
		return &ValidationError{Msg: "autoscale not provided"}
	}

	if a.MaxReplicas <= 0 {
		return &ValidationError{Msg: "max replicas must be greater than zero"}
	}

	if a.MinReplicas <= 0 {
		return &ValidationError{Msg: "min replicas must be greater than zero"}
	}

	if a.MinReplicas > a.MaxReplicas {
		return &ValidationError{Msg: "min replicas must not be greater than max replicas"}
	}

	if a.Cpu == nil && a.Memory == nil && a.Rps == nil && len(a.Schedules) == 0 {
		return &ValidationError{Msg: "you must provide either CPU, memory, RPS targets, or schedules"}
	}

	if cpu := a.Cpu; cpu != nil && *cpu <= 0 {
		return &ValidationError{Msg: "CPU must be greater than zero"}
	}

	if memory := a.Memory; memory != nil && *memory <= 0 {
		return &ValidationError{Msg: "memory must be greater than zero"}
	}

	if rps := a.Rps; rps != nil && *rps <= 0 {
		return &ValidationError{Msg: "RPS must be greater than zero"}
	}

	for _, s := range a.Schedules {
		if s.MinReplicas <= 0 {
			return &ValidationError{Msg: "scheduled window min replicas must be greater than zero"}
		}

		if s.MinReplicas > a.MaxReplicas {
			return &ValidationError{Msg: "scheduled window min replicas must be up to max replicas"}
		}

		if s.Start == "" {
			return &ValidationError{Msg: "start cron expression not provided"}
		}

		_, err := CronParser.Parse(s.Start)
		if err != nil {
			return &ValidationError{Msg: fmt.Sprintf("could not validate the scheduled window start cron expression %q: %s", s.Start, err)}
		}

		if s.End == "" {
			return &ValidationError{Msg: "end cron expression not provided"}
		}

		_, err = CronParser.Parse(s.End)
		if err != nil {
			return &ValidationError{Msg: fmt.Sprintf("could not validate the scheduled window end cron expression %q: %s", s.End, err)}
		}

		if s.Start == s.End {
			return &ValidationError{Msg: "start and end cannot have exactly the same cron expression"}
		}
	}

	return nil
}
