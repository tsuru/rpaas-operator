// Copyright 2019 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"time"

	tsuruclient "github.com/tsuru/go-tsuruclient/pkg/client"
	"github.com/urfave/cli/v3"

	rpaasclient "github.com/tsuru/rpaas-operator/pkg/rpaas/client"
	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
	"github.com/tsuru/rpaas-operator/version"
)

func NewDefaultApp() *cli.Command {
	return NewApp(os.Stdout, os.Stderr, nil)
}

func NewApp(o, e io.Writer, client rpaasclient.Client) (app *cli.Command) {
	app = &cli.Command{
		Usage:                 "Manipulates reverse proxy instances running on Reverse Proxy as a Service.",
		Version:               version.Version,
		EnableShellCompletion: true,
		ErrWriter:             e,
		Writer:                o,
		Commands: []*cli.Command{
			NewCmdScale(),
			NewCmdStart(),
			NewCmdStop(),
			NewCmdRestart(),
			NewCmdAccessControlList(),
			NewCmdCertificates(),
			NewCmdBlocks(),
			NewCmdRoutes(),
			NewCmdUpstreamOptions(),
			NewCmdInfo(),
			NewCmdAutoscale(),
			NewCmdDebug(),
			NewCmdExec(),
			NewCmdShell(),
			NewCmdLogs(),
			NewCmdExtraFiles(),
			NewCmdMetadata(),
			NewCmdPurge(),
		},
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:  "rpaas-url",
				Usage: "URL to RPaaS server",
			},
			&cli.StringFlag{
				Name:  "rpaas-user",
				Usage: "user name to authenticate on RPaaS server directly",
			},
			&cli.StringFlag{
				Name:  "rpaas-password",
				Usage: "password of user to authenticate on RPaaS server directly",
			},
			&cli.StringFlag{
				Name:    "tsuru-target",
				Usage:   "address of Tsuru server",
				Sources: cli.EnvVars("TSURU_TARGET"),
			},
			&cli.StringFlag{
				Name:        "tsuru-token",
				Usage:       "authentication credential to Tsuru server",
				Sources:     cli.EnvVars("TSURU_TOKEN"),
				DefaultText: "-",
			},
			&cli.DurationFlag{
				Name:  "timeout",
				Usage: "time limit that a remote operation (HTTP request) can take",
				Value: 60 * time.Second,
			},
			&cli.BoolFlag{
				Name:  "insecure",
				Usage: "whether should allow to perform requests under insecure connection",
			},
		},
		Before: func(ctx context.Context, cmd *cli.Command) (context.Context, error) {
			return setClient(ctx, client), nil
		},
	}
	return
}

type contextKey string

const rpaasClientKey = contextKey("rpaas.client")

var errClientNotFoundAtContext = fmt.Errorf("rpaas client not found at context")

func setClient(ctx context.Context, client rpaasclient.Client) context.Context {
	return context.WithValue(ctx, rpaasClientKey, client)
}

func getClient(ctx context.Context) (rpaasclient.Client, error) {
	client, ok := ctx.Value(rpaasClientKey).(rpaasclient.Client)
	if !ok {
		return nil, errClientNotFoundAtContext
	}

	return client, nil
}

func setupClient(ctx context.Context, cmd *cli.Command) (context.Context, error) {
	client, err := getClient(ctx)
	if err != nil && err != errClientNotFoundAtContext {
		return ctx, err
	}

	if client != nil {
		return ctx, nil
	}

	client, err = newClient(cmd)
	if err != nil {
		return ctx, err
	}

	return setClient(ctx, client), nil
}

func newClient(cmd *cli.Command) (rpaasclient.Client, error) {
	opts := rpaasclient.ClientOptions{Timeout: cmd.Duration("timeout")}
	if rpaasURL := cmd.String("rpaas-url"); rpaasURL != "" {
		return rpaasclient.NewClientWithOptions(rpaasURL, cmd.String("rpaas-user"), cmd.String("rpaas-password"), opts)
	}

	return rpaasclient.NewClientThroughTsuruWithOptions(cmd.String("tsuru-target"), cmd.String("tsuru-token"), cmd.String("tsuru-service"), opts)
}

func NewAutogeneratedClient(ctx context.Context, cmd *cli.Command) (context.Context, *autogenerated.APIClient) {
	cfg := &autogenerated.Configuration{
		UserAgent: fmt.Sprintf("rpaasv2-cli/%s", cmd.Version),
		HTTPClient: &http.Client{
			Timeout: cmd.Duration("timeout"),
			Transport: &http.Transport{
				Proxy: http.ProxyFromEnvironment,
				DialContext: (&net.Dialer{
					Timeout:   30 * time.Second,
					KeepAlive: 30 * time.Second,
				}).DialContext,
				ForceAttemptHTTP2:     true,
				MaxIdleConns:          100,
				IdleConnTimeout:       90 * time.Second,
				TLSHandshakeTimeout:   10 * time.Second,
				ExpectContinueTimeout: 1 * time.Second,
				TLSClientConfig: &tls.Config{
					InsecureSkipVerify: cmd.Bool("insecure"),
				},
			},
		},
	}

	if rpaasBaseURL := cmd.String("rpaas-url"); rpaasBaseURL != "" {
		cfg.Servers = autogenerated.ServerConfigurations{
			autogenerated.ServerConfiguration{URL: rpaasBaseURL},
		}

		if u, p := cmd.String("rpaas-user"), cmd.String("rpaas-password"); u != "" && p != "" {
			ctx = context.WithValue(ctx, autogenerated.ContextBasicAuth, autogenerated.BasicAuth{UserName: u, Password: p})
		}

		return ctx, autogenerated.NewAPIClient(cfg)
	}

	cfg.Servers = autogenerated.ServerConfigurations{
		autogenerated.ServerConfiguration{URL: cmd.String("tsuru-target")},
	}

	cfg.HTTPClient.Transport = &tsuruclient.TsuruProxyTransport{
		Target:   cmd.String("tsuru-target"),
		Token:    cmd.String("tsuru-token"),
		Service:  cmd.String("service"),
		Instance: cmd.String("instance"),
		Base:     cfg.HTTPClient.Transport,
	}

	return ctx, autogenerated.NewAPIClient(cfg)
}
