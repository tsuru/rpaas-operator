// Copyright 2019 tsuru authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package cmd

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/lnquy/cron"
	"github.com/olekukonko/tablewriter"
	"github.com/urfave/cli/v3"

	"github.com/tsuru/rpaas-operator/pkg/rpaas/client/autogenerated"
)

func NewCmdAutoscale() *cli.Command {
	return &cli.Command{
		Name:  "autoscale",
		Usage: "Manages autoscaling settings of an instance",
		Commands: []*cli.Command{
			NewCmdGetAutoscale(),
			NewCmdUpdateAutoscale(),
			NewCmdRemoveAutoscale(),
		},
	}
}

func NewCmdUpdateAutoscale() *cli.Command {
	return &cli.Command{
		Name:                      "add",
		Aliases:                   []string{"update"},
		Usage:                     "Updates the autoscaling parameters and targets of an reverse proxy instance",
		DisableSliceFlagSeparator: true,
		Description: `
# Scale up/down based on 75% of CPU utilization over all pods:
rpaasv2 autoscale update -s my-instance -i my-instance --min 2 --max 20 --cpu 75

# Scale up/down based on avg 100 HTTP requests per second:
rpaasv2 autoscale update -s my-service -i my-instance --min 2 --max 20 --rps 100

# Combine the two targets above together:
rpaasv2 autoscale update -s my-service -i my-instance --min 2 --max 20 --cpu 75 --rps 100

# Set a scheduled window to scale up at least one replica every weekday from 8 AM until 8 PM.
rpaasv2 autoscale update -s my-service -i my-instance \
	--min 0 --max 20 \
	--schedule '{"minReplicas": 1, "start": "00 08 * * 1-5", "end": "00 20 * * 1-5"}'

# Set two scheduled windows:
#	1) to scale up to max replicas every Tueday from 8 PM until at 0 PM (Wednesday)
#	2) to scale up to max replicas every Sunday all day
rpaasv2 autoscale update -s my-service -i my-instance \
	--min 2 --max 10 \
	--schedule '{"minReplicas": 10, "start": "00 20 * * 2", "end": "00 00 * * 3"}' \
	--schedule '{"minReplicas": 10, "start": "00 00 * * 0", "end": "59 23 * * 0"}'
`,
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "service",
				Aliases: []string{"tsuru-service", "s"},
				Usage:   "the Tsuru service name",
			},
			&cli.StringFlag{
				Name:     "instance",
				Aliases:  []string{"tsuru-service-instance", "i"},
				Usage:    "the reverse proxy instance name",
				Required: true,
			},
			&cli.IntFlag{
				Name:     "min",
				Usage:    "the lower limit of replicas that can be reached",
				Required: false,
			},
			&cli.IntFlag{
				Name:     "max",
				Usage:    "the upper limit of replicas that can be reached",
				Required: true,
			},
			&cli.IntFlag{
				Name:        "cpu",
				Aliases:     []string{"cpu-utilization"},
				Usage:       "the target average CPU utilization on all replicas (in percentage format, e.g. 80 equals to 80%)",
				DefaultText: "N/A",
			},
			&cli.IntFlag{
				Name:        "memory",
				Aliases:     []string{"memory-utilization"},
				Usage:       "the target average memory utilization on all the replicas (in percentage format, e.g. 80 equals to 80%)",
				DefaultText: "N/A",
			},
			&cli.IntFlag{
				Name:        "rps",
				Aliases:     []string{"requests-per-second"},
				Usage:       "the target average of HTTP requests per seconds between replicas (e.g. 100, means 100 req/s)",
				DefaultText: "N/A",
			},
			&cli.StringSliceFlag{
				Name:    "schedule",
				Aliases: []string{"scheduled-window"},
				Usage:   "the time-window where the instance can scale in/out regardless of traffic or resource utilization",
			},
		},
		Action: runUpdateAutoscale,
	}
}

func runUpdateAutoscale(ctx context.Context, cmd *cli.Command) error {
	var schedules []autogenerated.ScheduledWindow
	for _, s := range cmd.StringSlice("schedule") {
		var sw autogenerated.ScheduledWindow
		if err := json.Unmarshal([]byte(s), &sw); err != nil {
			return err
		}

		schedules = append(schedules, sw)
	}

	var cpu *int32
	if n := cmd.Int("cpu"); cmd.IsSet("cpu") && n > 0 {
		cpu = autogenerated.PtrInt32(int32(n))
	}

	var memory *int32
	if n := cmd.Int("memory"); cmd.IsSet("memory") && n > 0 {
		memory = autogenerated.PtrInt32(int32(n))
	}

	var rps *int32
	if n := cmd.Int("rps"); cmd.IsSet("rps") && n > 0 {
		rps = autogenerated.PtrInt32(int32(n))
	}

	autoscale := autogenerated.Autoscale{
		MinReplicas: int32(cmd.Int("min")),
		MaxReplicas: int32(cmd.Int("max")),
		Cpu:         cpu,
		Memory:      memory,
		Rps:         rps,
		Schedules:   schedules,
	}

	ctx, apiClient := NewAutogeneratedClient(ctx, cmd)
	_, err := apiClient.RpaasApi.UpdateAutoscale(ctx, cmd.String("instance")).Autoscale(autoscale).Execute()
	if err != nil {
		var apiErr *autogenerated.GenericOpenAPIError
		if errors.As(err, &apiErr) {
			return fmt.Errorf("could not update the autoscale on RPaaS API: %s\n%s", apiErr.Error(), apiErr.Body())
		}
		return fmt.Errorf("could not update the autoscale on RPaaS API: %w", err)
	}

	fmt.Fprintf(cmd.Root().Writer, "Autoscale of %s successfully updated!\n", formatInstanceName(cmd))
	return nil
}

func NewCmdGetAutoscale() *cli.Command {
	return &cli.Command{
		Name:  "info",
		Usage: "Shows  the autoscaling settings",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "service",
				Aliases: []string{"tsuru-service", "s"},
				Usage:   "the Tsuru service name",
			},
			&cli.StringFlag{
				Name:     "instance",
				Aliases:  []string{"tsuru-service-instance", "i"},
				Usage:    "the reverse proxy instance name",
				Required: true,
			},
			&cli.BoolFlag{
				Name:  "json",
				Usage: "show as JSON instead of go template format",
				Value: false,
			},
		},
		Action: runGetAutoscale,
	}
}

func runGetAutoscale(ctx context.Context, cmd *cli.Command) error {
	ctx, apiClient := NewAutogeneratedClient(ctx, cmd)
	autoscale, _, err := apiClient.RpaasApi.GetAutoscale(ctx, cmd.String("instance")).Execute()
	if err != nil {
		var apiErr *autogenerated.GenericOpenAPIError
		if errors.As(err, &apiErr) {
			return fmt.Errorf("could not get autoscale from RPaaS API: %s\n%s", apiErr.Error(), apiErr.Body())
		}
		return fmt.Errorf("could not get autoscale from RPaaS API: %w", err)
	}

	if outputAsJSON := cmd.Bool("json"); outputAsJSON {
		return writeJSON(cmd.Root().Writer, autoscale)
	}

	writeAutoscale(cmd.Root().Writer, autoscale)
	return nil
}

func NewCmdRemoveAutoscale() *cli.Command {
	return &cli.Command{
		Name:    "remove",
		Usage:   "Removes the autoscaling parameters of instance",
		Aliases: []string{"delete"},
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "service",
				Aliases: []string{"tsuru-service", "s"},
				Usage:   "the Tsuru service name",
			},
			&cli.StringFlag{
				Name:     "instance",
				Aliases:  []string{"tsuru-service-instance", "i"},
				Usage:    "the reverse proxy instance name",
				Required: true,
			},
		},
		Action: runRemoveAutoscale,
	}
}

func runRemoveAutoscale(ctx context.Context, cmd *cli.Command) error {
	ctx, apiClient := NewAutogeneratedClient(ctx, cmd)
	_, err := apiClient.RpaasApi.RemoveAutoscale(ctx, cmd.String("instance")).Execute()
	if err != nil {
		var apiErr *autogenerated.GenericOpenAPIError
		if errors.As(err, &apiErr) {
			return fmt.Errorf("could not delete the autoscale on RPaaS API: %s\n%s", apiErr.Error(), apiErr.Body())
		}
		return fmt.Errorf("could not delete the autoscale on RPaaS API: %w", err)
	}

	fmt.Fprintf(cmd.Root().Writer, "Autoscale of %s successfully removed\n", formatInstanceName(cmd))
	return nil
}

func writeAutoscale(w io.Writer, autoscale *autogenerated.Autoscale) {
	if autoscale == nil {
		return
	}

	fmt.Fprintf(w, "Autoscale: (min replicas: %d, max replicas: %d)\n", autoscale.MinReplicas, autoscale.MaxReplicas)

	table := tablewriter.NewWriter(w)
	table.SetHeader([]string{"Triggers", "trigger details"})
	table.SetAutoFormatHeaders(false)
	table.SetHeaderAlignment(tablewriter.ALIGN_CENTER)
	table.SetAutoWrapText(false)
	table.SetRowLine(false)

	if autoscale.Cpu != nil {
		table.Append([]string{"CPU", fmt.Sprintf("%d%%", int(*autoscale.Cpu))})
	}

	if autoscale.Memory != nil {
		table.Append([]string{"Memory", fmt.Sprintf("%d%%", int(*autoscale.Memory))})
	}

	if autoscale.Rps != nil {
		table.Append([]string{"RPS", fmt.Sprintf("%d req/s", int(*autoscale.Rps))})
	}

	var schedules strings.Builder
	exprDesc, _ := cron.NewDescriptor()
	for i, s := range autoscale.Schedules {
		if i > 0 {
			fmt.Fprintln(&schedules)
			fmt.Fprintln(&schedules)
		}

		fmt.Fprintf(&schedules, "Window %d:\n", i+1)
		fmt.Fprintln(&schedules, "  Min replicas:", s.MinReplicas)

		human, _ := exprDesc.ToDescription(s.Start, cron.Locale_en)
		fmt.Fprintf(&schedules, "  Start: %s (%s)\n", human, s.Start)

		human, _ = exprDesc.ToDescription(s.End, cron.Locale_en)
		fmt.Fprintf(&schedules, "  End: %s (%s)", human, s.End)

		timezone := s.GetTimezone()
		if timezone != "" {
			fmt.Fprintf(&schedules, "\n  Timezone: %s", timezone)
		}
	}

	if text := schedules.String(); text != "" {
		table.Append([]string{"Schedule(s)", text})
	}
	table.Render()
}

func writeJSON(w io.Writer, v any) error {
	e := json.NewEncoder(w)
	e.SetIndent("", "\t")
	return e.Encode(v)
}
